(define (attach-tag type-tag contents)
  (if (and (number? contents) (eq? type-tag 'scheme-number))
      contents
      (cons type-tag contents)))

(define (type-tag datum)
  (cond ((number? datum) 'scheme-number)
        ((pair? datum) (car datum))
        (else (error "Bad tagged datum -- TYPE-TAG" datum))))

(define (contents datum)
  (cond ((number? datum) datum)
        ((pair? datum) (cdr datum))
        (else (error "Bad taged datum -- CONTENTS" datum))))

(define (equ? x y) (apply-generic 'equ? x y))

(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (define (raise-to-rational x) ((get 'make-from-numer-denom 'rational) x 1))
  (put 'equ? '(scheme-number scheme-number) =)
  (put 'make 'scheme-number (lambda (x) (tag x)))
  (put 'raise 'scheme-number raise-to-rational)
  'done)

(define (install-rational-package)
  (define (make-scheme-number x) ((get 'make 'scheme-number) x))
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d) (cons n d))
  (define (equ? r1 r2) (and (= (numer r1) (numer r2))
                            (= (denom r1) (denom r2))))
  (define (project r) (make-scheme-number (round (/ (numer r) (denom r)))))
  (define (raise-to-complex r) ((get 'make-from-real-img 'complex) r 0))
  (define (tag x) (attach-tag 'rational x))
  (put 'equ? '(rational rational) equ?)
  (put 'make-from-numer-denom 'rational (lambda (n d) (tag (make-rat n d))))
  (put 'project 'rational project)
  (put 'raise 'rational raise-to-complex)
  'done)

(define (install-complex-package)
  (define (make-from-real-imag x y) (cons x y))
  (define (make-rational x y) ((get 'make 'rational) x y))
  (define (real-part c) (car c))
  (define (imag-part c) (cdr c))
  (define (equ? c1 c2) (and (= (real-part c1) (real-part c2))
                            (= (imag-part c1) (imag-part c2))))
  (define (project c) (make-rational (real-part c) 1))
  (define (tag x) (attach-tag 'complex x))
  (put 'equ? '(complex complex) equ? x y)
  (put 'project '(complex) project)
  (put 'make-from-real-img 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  'done)

(define (raise x)
  (let ((rf (get 'raise (type-tag x))))
    (rf x)))

(define (height x)
  (define (height-itr current cnt)
    (let ((current-tag (type-tag current)))
      (if (eq? current-tag 'complex)
          cnt
          (height-itr (raise current) (+ cnt 1)))))
  (height-itr x 0))

(define (raise-to x type)
  (if (eq? (type-tag x) type)
      x
      (raise-to (raise x) type)))

(define (equ? x y)
  (let ((f (get 'equ? (type-tag x) (type-tag y))))
    (if f
        (f x y)
        (error "No equ?" (list x y)))))

(define (drop arg)
  (let ((project (get 'project (type-tag arg))))
    (if project
        (let (check (raise (project arg)))
          (if (equ? check arg)
              (drop (project arg))
              arg))
        arg)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (drop (apply proc (map contents args)))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args))
                    (height1 (height a1))
                    (height2 (height a2)))
                (if (< height1 height2)
                    (let ((raised (raise-to a2 type1)))
                      (apply-generic op a1 raised))
                    (let ((raised (raise-to a1 type2)))
                      (apply-generic op raised a2))))
              (error "No method for these types" (list op type-tags)))))))
